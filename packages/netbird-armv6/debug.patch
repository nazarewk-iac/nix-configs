diff --git a/util/grpc/dialer.go b/util/grpc/dialer.go
index 57ab8fd5..6becdb81 100644
--- a/util/grpc/dialer.go
+++ b/util/grpc/dialer.go
@@ -3,6 +3,7 @@ package grpc
 import (
 	"context"
 	"crypto/tls"
+	"fmt"
 	"net"
 	"os/user"
 	"runtime"
@@ -20,24 +21,29 @@ import (
 
 func WithCustomDialer() grpc.DialOption {
 	return grpc.WithContextDialer(func(ctx context.Context, addr string) (net.Conn, error) {
+		log.Infof("Custom dialer called for address: %s", addr)
 		if runtime.GOOS == "linux" {
 			currentUser, err := user.Current()
 			if err != nil {
-				log.Fatalf("failed to get current user: %v", err)
+				log.Errorf("Failed to get current user: %v", err)
+				return nil, fmt.Errorf("failed to get current user: %w", err)
 			}
 
-			// the custom dialer requires root permissions which are not required for use cases run as non-root
+			log.Infof("Current user UID: %s", currentUser.Uid)
 			if currentUser.Uid != "0" {
+				log.Debug("Not running as root, using standard dialer")
 				dialer := &net.Dialer{}
 				return dialer.DialContext(ctx, "tcp", addr)
 			}
 		}
 
+		log.Debug("Using nbnet.NewDialer()")
 		conn, err := nbnet.NewDialer().DialContext(ctx, "tcp", addr)
 		if err != nil {
-			log.Errorf("Failed to dial: %s", err)
+			log.Errorf("nbnet.NewDialer().DialContext failed: %v", err)
 			return nil, err
 		}
+		log.Debug("nbnet.NewDialer().DialContext succeeded")
 		return conn, nil
 	})
 }
diff --git a/util/net/dialer_nonios.go b/util/net/dialer_nonios.go
index 7a5de758..5f7b9fed 100644
--- a/util/net/dialer_nonios.go
+++ b/util/net/dialer_nonios.go
@@ -65,10 +65,13 @@ func (d *Dialer) DialContext(ctx context.Context, network, address string) (net.
 		}
 	}
 
+	log.Infof("Dialing %s %s", network, address)
 	conn, err := d.Dialer.DialContext(ctx, network, address)
 	if err != nil {
+		log.Errorf("d.Dialer.DialContext failed: %v", err)
 		return nil, fmt.Errorf("dial: %w", err)
 	}
+	log.Debug("d.Dialer.DialContext succeeded")
 
 	// Wrap the connection in Conn to handle Close with hooks
 	return &Conn{Conn: conn, ID: connID}, nil
diff --git a/util/net/net_linux.go b/util/net/net_linux.go
index 954545eb..dab70f22 100644
--- a/util/net/net_linux.go
+++ b/util/net/net_linux.go
@@ -5,6 +5,8 @@ package net
 import (
 	"fmt"
 	"syscall"
+
+	log "github.com/sirupsen/logrus"
 )
 
 // SetSocketMark sets the SO_MARK option on the given socket connection
@@ -21,23 +23,35 @@ func SetRawSocketMark(conn syscall.RawConn) error {
 	var setErr error
 
 	err := conn.Control(func(fd uintptr) {
+		log.Infof("In Control function, fd: %d", fd)
 		setErr = SetSocketOpt(int(fd))
 	})
 	if err != nil {
+		log.Errorf("Control function failed: %v", err)
 		return fmt.Errorf("control: %w", err)
 	}
 
 	if setErr != nil {
+		log.Errorf("SetSocketOpt failed: %v", setErr)
 		return fmt.Errorf("set SO_MARK: %w", setErr)
 	}
 
+	log.Debug("SetRawSocketMark completed successfully")
 	return nil
 }
 
 func SetSocketOpt(fd int) error {
+	log.Infof("Attempting to set SO_MARK on fd %d", fd)
 	if CustomRoutingDisabled() {
+		log.Debug("Custom routing is disabled, skipping SO_MARK")
 		return nil
 	}
 
-	return syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_MARK, NetbirdFwmark)
+	err := syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_MARK, NetbirdFwmark)
+	if err != nil {
+		log.Errorf("Failed to set SO_MARK: %v", err)
+	} else {
+		log.Infof("Successfully set SO_MARK to %d", NetbirdFwmark)
+	}
+	return err
 }
